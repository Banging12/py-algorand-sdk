from tabulate import tabulate
from typing import List
import base64


class DryrunResponse:
    def __init__(self, drrjson: dict, hide_default_scratch: bool = True):
        self.raw_response: dict = drrjson
        for param in ["error", "protocol-version", "txns"]:
            assert (
                param in drrjson
            ), f"expecting dryrun response object to have key '{param}' but it is missing"

        # These are all required fields
        self.error = drrjson["error"]
        self.protocol = drrjson["protocol-version"]
        self.txns = [
            DryrunTransactionResult(txn) for txn in self.raw_response["txns"]
        ]


class DryrunTransactionResult:
    DEFAULT_TRACE_SPACES: int = 20

    def __init__(self, dr):
        self.txn = dr
        assert (
            "disassembly" in dr
        ), "expecting dryrun transaction result to have key 'disassembly' but its missing"

        self.disassembly = dr["disassembly"]

        optionals = [
            "app-call-messages",
            "local-deltas",
            "global-delta",
            "cost",
            "logic-sig-messages",
            "logic-sig-disassembly",
            "logs",
        ]
        for field in optionals:
            if field in dr:
                setattr(self, field.replace("-", "_"), dr[field])
            else:
                setattr(self, field.replace("-", "_"), None)

        traces = ["app-call-trace", "logic-sig-trace"]
        for trace_field in traces:
            if trace_field in dr:
                setattr(
                    self,
                    trace_field.replace("-", "_"),
                    DryrunTrace(dr[trace_field]),
                )

    def app_call_rejected(self) -> bool:
        if self.app_call_messages is not None:
            return "REJECT" in self.app_call_messages
        return False

    def logic_sig_rejected(self) -> bool:
        if self.logic_sig_messages is not None:
            return "REJECT" in self.logic_sig_messages
        return False

    @classmethod
    def trace(
        cls,
        dr_trace: "DryrunTrace",
        disassembly: List[str],
    ) -> str:
        scratch = dr_trace.get_scratch()
        table = [
            (pc, line, disassembly[line], stack, scratch)
            for line, pc, stack, scratch in dr_trace.get_trace()
        ]
        return tabulate(
            table,
            headers=("PC#", "L#", "source", "stack", "scratch"),
            tablefmt="presto",
        )

    def app_trace(self, spaces: int = None) -> str:
        if not hasattr(self, "app_call_trace"):
            return ""

        return self.trace(
            self.app_call_trace, self.disassembly
        )  # , spaces=spaces)

    def lsig_trace(self, spaces: int = None) -> str:
        if not hasattr(self, "logic_sig_trace"):
            return ""

        if (
            not hasattr(self, "logic_sig_disassembly")
            or self.logic_sig_disassembly is None
        ):
            return ""

        return self.trace(
            self.logic_sig_trace, self.logic_sig_disassembly
        )  # , spaces=spaces


class DryrunTrace:
    def __init__(self, trace: List[dict]):
        self.trace = [DryrunTraceLine(line) for line in trace]

    def get_trace(self) -> List[list]:
        return [line.trace_line() for line in self.trace]

    # >>> results_list = [[1,2,3], [1,2,4]]
    # >>> results_union = set().union(*results_list)
    def get_scratch(self) -> List[list]:
        scratches = [line.trace_line()[-1] for line in self.trace]
        slots = sorted(set().union(*(s.keys() for s in scratches)))
        return [
            [f"{k}:{s[k]}" if k in s else "" for k in slots] for s in scratches
        ]


class DryrunTraceLine:
    def __init__(self, tl, shrink_scratch: bool = True):
        self.line = tl["line"]
        self.pc = tl["pc"]
        self.stack = [str(DryrunValue(sv)) for sv in tl["stack"]]

        scratch = {i: val for i, val in enumerate(tl.get("scratch", []))}
        if shrink_scratch:

            def keeper(val):
                return val["uint"] or val["bytes"]

            scratch = {i: val for i, val in scratch.items() if keeper(val)}

        self.scratch = {i: str(DryrunValue(sc)) for i, sc in scratch.items()}

    def trace_line(self):
        return (
            self.line,
            self.pc,
            self.stack,
            self.scratch,
            # "[" + ", ".join([str(sv) for sv in self.stack]) + "]",
        )


class DryrunValue:
    def __init__(self, v):
        self.type = v["type"]
        self.bytes = v["bytes"]
        self.int = v["uint"]

    def __str__(self) -> str:
        if self.type == 1:
            return "0x" + base64.b64decode(self.bytes).hex()
        return str(self.int)
